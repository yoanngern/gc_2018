{"version":3,"sources":["ecommerce3/assets/js/cart.js"],"names":["require","undefined","e","t","n","r","s","o","u","a","i","f","Error","code","l","exports","call","length","1","module","isEmailAddressValid","emailAddress","regex","test","sendFormData","data","serialize","checkoutForm","hash","previous_billing_email","previousEmailAddress","allowedFields","dataString","JSON","stringify","billing_email","previousDataString","request","XMLHttpRequest","open","ajaxurl","setRequestHeader","send","scheduledFunctionCall","document","querySelector","formSubmitted","mc4wp_ecommerce_cart","ajax_url","woocommerce_params","addEventListener","window","clearTimeout","setTimeout","form-serialize","2","form","options","result","serializer","hash_serializer","str_serialize","elements","radio_store","Object","create","element","disabled","name","k_r_success_contrls","nodeName","k_r_submitter","type","key","val","value","checked","empty","selectOptions","isSelectedOptions","j","option","allowedEmpty","hasValue","selected","slice","parse_keys","string","keys","prefix","children","RegExp","brackets","match","exec","push","hash_assign","shift","between","Array","isArray","_values","index","isNaN","matches","existing","replace","encodeURIComponent"],"mappings":"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","file":"cart.min.js","sourcesContent":["(function () { var require = undefined; var define = undefined; (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n'use strict';\n\nvar checkoutForm = document.querySelector('form.woocommerce-checkout, form[name=\"checkout\"]');\nvar previousEmailAddress;\nvar previousDataString;\nvar scheduledFunctionCall;\nvar formSubmitted = false;\nvar serialize = require('form-serialize');\nvar ajaxurl = typeof(mc4wp_ecommerce_cart) !== \"undefined\" ? mc4wp_ecommerce_cart.ajax_url : woocommerce_params.ajax_url;\n\nfunction isEmailAddressValid(emailAddress) {\n   var regex = /\\S+@\\S+\\.\\S+/;\n   return regex.test(emailAddress);\n}\n\nfunction sendFormData() {\n   var data = serialize(checkoutForm, { hash: true });\n   data.previous_billing_email = previousEmailAddress;\n   var allowedFields = [ 'billing_email', 'billing_first_name', 'billing_last_name', 'billing_address_1', 'billing_address_2', 'billing_city', 'billing_state', 'billing_country' ];\n   var dataString = JSON.stringify(data, allowedFields);\n\n   // schedule cart update if email looks valid && data changed.\n   if( isEmailAddressValid(data.billing_email) && dataString != previousDataString ) {\n      var request = new XMLHttpRequest();\n      request.open('POST', ajaxurl + \"?action=mc4wp_ecommerce_schedule_cart\", true);\n      request.setRequestHeader('Content-Type', 'application/json');\n      request.send(dataString);\n\n      previousDataString = dataString;\n      previousEmailAddress = data.billing_email;\n   }\n}\n\nif( checkoutForm ) {\n   // don't send more than once every 6 seconds\n   checkoutForm.addEventListener('change', function() {\n      scheduledFunctionCall && window.clearTimeout(scheduledFunctionCall);\n      scheduledFunctionCall = window.setTimeout(sendFormData, 6000);\n   });\n\n   checkoutForm.addEventListener('submit', function() {\n      formSubmitted = true;\n   });\n\n   // always send before unloading window, but not if form was submitted\n   window.addEventListener('beforeunload', function() {\n      if( ! formSubmitted ) {\n         sendFormData();\n      }\n   });\n}\n\n\n},{\"form-serialize\":2}],2:[function(require,module,exports){\n// get successful control from form and assemble into object\n// http://www.w3.org/TR/html401/interact/forms.html#h-17.13.2\n\n// types which indicate a submit action and are not successful controls\n// these will be ignored\nvar k_r_submitter = /^(?:submit|button|image|reset|file)$/i;\n\n// node names which could be successful controls\nvar k_r_success_contrls = /^(?:input|select|textarea|keygen)/i;\n\n// Matches bracket notation.\nvar brackets = /(\\[[^\\[\\]]*\\])/g;\n\n// serializes form fields\n// @param form MUST be an HTMLForm element\n// @param options is an optional argument to configure the serialization. Default output\n// with no options specified is a url encoded string\n//    - hash: [true | false] Configure the output type. If true, the output will\n//    be a js object.\n//    - serializer: [function] Optional serializer function to override the default one.\n//    The function takes 3 arguments (result, key, value) and should return new result\n//    hash and url encoded str serializers are provided with this module\n//    - disabled: [true | false]. If true serialize disabled fields.\n//    - empty: [true | false]. If true serialize empty fields\nfunction serialize(form, options) {\n    if (typeof options != 'object') {\n        options = { hash: !!options };\n    }\n    else if (options.hash === undefined) {\n        options.hash = true;\n    }\n\n    var result = (options.hash) ? {} : '';\n    var serializer = options.serializer || ((options.hash) ? hash_serializer : str_serialize);\n\n    var elements = form && form.elements ? form.elements : [];\n\n    //Object store each radio and set if it's empty or not\n    var radio_store = Object.create(null);\n\n    for (var i=0 ; i<elements.length ; ++i) {\n        var element = elements[i];\n\n        // ingore disabled fields\n        if ((!options.disabled && element.disabled) || !element.name) {\n            continue;\n        }\n        // ignore anyhting that is not considered a success field\n        if (!k_r_success_contrls.test(element.nodeName) ||\n            k_r_submitter.test(element.type)) {\n            continue;\n        }\n\n        var key = element.name;\n        var val = element.value;\n\n        // we can't just use element.value for checkboxes cause some browsers lie to us\n        // they say \"on\" for value when the box isn't checked\n        if ((element.type === 'checkbox' || element.type === 'radio') && !element.checked) {\n            val = undefined;\n        }\n\n        // If we want empty elements\n        if (options.empty) {\n            // for checkbox\n            if (element.type === 'checkbox' && !element.checked) {\n                val = '';\n            }\n\n            // for radio\n            if (element.type === 'radio') {\n                if (!radio_store[element.name] && !element.checked) {\n                    radio_store[element.name] = false;\n                }\n                else if (element.checked) {\n                    radio_store[element.name] = true;\n                }\n            }\n\n            // if options empty is true, continue only if its radio\n            if (val == undefined && element.type == 'radio') {\n                continue;\n            }\n        }\n        else {\n            // value-less fields are ignored unless options.empty is true\n            if (!val) {\n                continue;\n            }\n        }\n\n        // multi select boxes\n        if (element.type === 'select-multiple') {\n            val = [];\n\n            var selectOptions = element.options;\n            var isSelectedOptions = false;\n            for (var j=0 ; j<selectOptions.length ; ++j) {\n                var option = selectOptions[j];\n                var allowedEmpty = options.empty && !option.value;\n                var hasValue = (option.value || allowedEmpty);\n                if (option.selected && hasValue) {\n                    isSelectedOptions = true;\n\n                    // If using a hash serializer be sure to add the\n                    // correct notation for an array in the multi-select\n                    // context. Here the name attribute on the select element\n                    // might be missing the trailing bracket pair. Both names\n                    // \"foo\" and \"foo[]\" should be arrays.\n                    if (options.hash && key.slice(key.length - 2) !== '[]') {\n                        result = serializer(result, key + '[]', option.value);\n                    }\n                    else {\n                        result = serializer(result, key, option.value);\n                    }\n                }\n            }\n\n            // Serialize if no selected options and options.empty is true\n            if (!isSelectedOptions && options.empty) {\n                result = serializer(result, key, '');\n            }\n\n            continue;\n        }\n\n        result = serializer(result, key, val);\n    }\n\n    // Check for all empty radio buttons and serialize them with key=\"\"\n    if (options.empty) {\n        for (var key in radio_store) {\n            if (!radio_store[key]) {\n                result = serializer(result, key, '');\n            }\n        }\n    }\n\n    return result;\n}\n\nfunction parse_keys(string) {\n    var keys = [];\n    var prefix = /^([^\\[\\]]*)/;\n    var children = new RegExp(brackets);\n    var match = prefix.exec(string);\n\n    if (match[1]) {\n        keys.push(match[1]);\n    }\n\n    while ((match = children.exec(string)) !== null) {\n        keys.push(match[1]);\n    }\n\n    return keys;\n}\n\nfunction hash_assign(result, keys, value) {\n    if (keys.length === 0) {\n        result = value;\n        return result;\n    }\n\n    var key = keys.shift();\n    var between = key.match(/^\\[(.+?)\\]$/);\n\n    if (key === '[]') {\n        result = result || [];\n\n        if (Array.isArray(result)) {\n            result.push(hash_assign(null, keys, value));\n        }\n        else {\n            // This might be the result of bad name attributes like \"[][foo]\",\n            // in this case the original `result` object will already be\n            // assigned to an object literal. Rather than coerce the object to\n            // an array, or cause an exception the attribute \"_values\" is\n            // assigned as an array.\n            result._values = result._values || [];\n            result._values.push(hash_assign(null, keys, value));\n        }\n\n        return result;\n    }\n\n    // Key is an attribute name and can be assigned directly.\n    if (!between) {\n        result[key] = hash_assign(result[key], keys, value);\n    }\n    else {\n        var string = between[1];\n        // +var converts the variable into a number\n        // better than parseInt because it doesn't truncate away trailing\n        // letters and actually fails if whole thing is not a number\n        var index = +string;\n\n        // If the characters between the brackets is not a number it is an\n        // attribute name and can be assigned directly.\n        if (isNaN(index)) {\n            result = result || {};\n            result[string] = hash_assign(result[string], keys, value);\n        }\n        else {\n            result = result || [];\n            result[index] = hash_assign(result[index], keys, value);\n        }\n    }\n\n    return result;\n}\n\n// Object/hash encoding serializer.\nfunction hash_serializer(result, key, value) {\n    var matches = key.match(brackets);\n\n    // Has brackets? Use the recursive assignment function to walk the keys,\n    // construct any missing objects in the result tree and make the assignment\n    // at the end of the chain.\n    if (matches) {\n        var keys = parse_keys(key);\n        hash_assign(result, keys, value);\n    }\n    else {\n        // Non bracket notation can make assignments directly.\n        var existing = result[key];\n\n        // If the value has been assigned already (for instance when a radio and\n        // a checkbox have the same name attribute) convert the previous value\n        // into an array before pushing into it.\n        //\n        // NOTE: If this requirement were removed all hash creation and\n        // assignment could go through `hash_assign`.\n        if (existing) {\n            if (!Array.isArray(existing)) {\n                result[key] = [ existing ];\n            }\n\n            result[key].push(value);\n        }\n        else {\n            result[key] = value;\n        }\n    }\n\n    return result;\n}\n\n// urlform encoding serializer\nfunction str_serialize(result, key, value) {\n    // encode newlines as \\r\\n cause the html spec says so\n    value = value.replace(/(\\r)?\\n/g, '\\r\\n');\n    value = encodeURIComponent(value);\n\n    // spaces should be '+' rather than '%20'.\n    value = value.replace(/%20/g, '+');\n    return result + (result ? '&' : '') + encodeURIComponent(key) + '=' + value;\n}\n\nmodule.exports = serialize;\n\n},{}]},{},[1]);\n })();"]}